---
title: "RATs Tutorial"
author: "Kimon Froussios"
date: "23 JAN 2017"
output: 
  html_document: 
    fig_caption: no
    keep_md: yes
    theme: readable
    toc: yes
abstract: >
  The [rats](http://github.com/bartongroup/Rats) package is aimed at people analysing **gene expression** and **transcript abundance**, 
  particularly with **RNA-Seq** type of data in mind. This vignette constitutes the main 
  documentation for the package.
vignette: >
  %\VignetteIndexEntry{RATs Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


# Introduction, installation and quick-start

For package introduction and installation instructions, please refer to the Quick Start vignette.


***


# The package in detail

```{r}
# Load package.
library(rats)
```

## Input formats

### Data

RATs can work with any of three input types:

1. A [Sleuth](http://pachterlab.github.io/sleuth/) object.
2. Generic bootstrapped abundance estimates.
3. Generic abundance estimates.

-> From a [Sleuth](http://pachterlab.github.io/sleuth/) object RATs extracts the bootstrapped abundance estimates. 
To find out more about Sleuth-based workflows refer to the following links:
[introduction to Sleuth](http://rawgit.com/pachterlab/sleuth/master/inst/doc/intro.html),
[Kallisto](http://pachterlab.github.io/kallisto/),
[wasabi](http://github.com/COMBINE-lab/wasabi),
[Sailfish](http://github.com/kingsfordgroup/sailfish),
[Salmon](https://github.com/COMBINE-lab/salmon).

-> Bootstrapped abundance estimates obtained by other means can be input as `list`s of `data.table`s. Two lists are needed, one per condition.
Each datatable should contain the transcript identifiers in the first column, followed by columns containing the estimates from the bootstrap iterations:

```{r}
# Show the first rows of the table corresponding to one sample, from simulated data.
head(sim_boot_data()[[2]][[1]])
```

-> Generic abundance estimates, without bootstrapping information, can be input simply as two `data.table`s, one per condition. The first column should
contain the transcript identifiers, followed by columns listing the abundance per sample. The format of each table is identical to the one shown above,
only the meaning of the numbers changes.

### Annotation

Regardless of data format, `rats` also needs an annotation `data.frame` or `data.table` that matches transcript identifiers to gene identifiers. This looks like this:

```{r}
# Show the first rows of the table corresponding to the annotation, from simulated data.
head(sim_count_data()[[1]])
```

A function is provided to create this table, given a GTF file.
**Note:** GFF3 is **not** supported, as the specification is too relaxed.

```{r eval=FALSE}
# Extract transcript ID to gene ID index from a GTF annotation.
myannot <- annot2ids("my_annotation_file.gtf")
```

Other ways to create the annotation table exist, for example using the [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html)
interface, but they are beyond the scope of this tutorial.


***


## Calling DTU 

To bypass the complexity of running third-party tools in this tutorial, we will instead use **emulated data**. `rats` comes
with data emulators, intended to be used for testing the code. However, they are also convenient to use for showcasing
how `rats` works. If you happen to have real data available, go ahead and use that instead if you wish.

By default, `rats` reports on its progress and produces a summary report.
The progress messages and summary can be suppressed by adding the `verbose = FALSE` parameter to the call. 
To prevent cluttering this tutorial with verbose output, we will use this option in all the examples.

If you leave `verbose = TRUE` when trying out the examples below using the emulated data, you will get **warnings**
about the number of bootstraps. The warning is triggered because the emulated dataset used in the examples immitates only the structure of 
real data, not the actual volume of it, and as such contains too few bootstrap iterations.


### with generic abundance estimates, without bootstraps

This is the simplest usage case, provided only for completeness. We recommend using bootstrapped data whenever possible,
for reasons that will be discussed in the relevant section below.

First, let's emulate some data to work with:

```{r}
# Simulate some data.
simdat <- sim_count_data()

# For convenience let's assign the contents of the list to separate variables.
mycond_A <- simdat[[2]]          # Simulated abundances for one condition.
mycond_B <- simdat[[3]]          # Simulated abundances for other condition.
myannot <- simdat[[1]]   # Transcript and gene IDs for the above data.
```

Now we can call DTU:

```{r}
# Find DTU between the simulated datasets.
mydtu <- call_DTU(annot= myannot, count_data_A= mycond_A, count_data_B= mycond_B, 
                  boots= "none", verbose= FALSE,
                  name_A= "healthy", name_B= "patients", varname= "My phenotype",
                  description="Comparison of two simulated counts datasets for the
                               tutorial. Simulated using built-in functionality of 
                               `rats`.")
```

`call_DTU()` takes 4 mandatory arguments for this input format. 

1. An annotation data frame, as described in the Input section.
2. `boots` must only take the value `"none"` in this case, as no bootstrap data is provided in the input.
3. `count_data_A` and `count_data_B` are each a `data.table` as described in the Input section.

`name_A`, `name_B`, `varname` and `description` are optional meta-data that will be recorded in the results object.
Their values can also be added after the run, by editing the relevant fields of the returned object's `Parameters` element.


### with generic bootstrapped abundance estimates

First, let's emulate some data, as we did before.

```{r}
# Simulate some data. (Notice it is a different function than before.)
simdat <- sim_boot_data()

# For convenience let's assign the contents of the list to separate variables.
mycond_A <- simdat[[2]]          # Simulated bootstrapped data for one condition.
mycond_B <- simdat[[3]]          # Simulated bootstrapped data for other condition.
myannot <- simdat[[1]]   # Transcript and gene Identifiers for the above data.
```

Now we can call DTU:

```{r}
# Find DTU between conditions "controls" and "patients" in the simulated data.
mydtu <- call_DTU(annot= myannot, boot_data_A= mycond_A, boot_data_B= mycond_B, 
                  name_A= "wildtype", name_B= "some mutant", varname = "My phenotype",
                  verbose= FALSE, description="Comparison of two simulated datasets 
                    of bootstrapped counts for the tutorial. Simulated using built-in 
                    functionality of `rats`.")
```

`call_DTU()` takes 3 mandatory arguments for this input format. 

1. An annotation data frame, as described in the Input section.
2. `boot_data_A` and `boot_data_B` are each a list of `data.table` objects, as described in the Input section.

`name_A`, `name_B`, `varname` and `description` are optional meta-data that will be recorded in the results object.
Their values can also be added after the run, by editing the relevant fields of the returned object's `Parameters` element.


### with a sleuth object

First, let's emulate a Sleuth object, using the bundled tools. The real Sleuth objects are very large and very complex nested lists. 
The emulated one contains only the minimum essential elements relevant to calling DTU with `rats`. 

```{r}
# Simulate some data.
simdat <- sim_sleuth_data(cnames = c("controls", "patients")) 
# controls and patients are arbitrary names to use as conditions.

# For convenience let's assign the contents of the list to separate variables.
myslo <- simdat$slo       # Simulated minimal sleuth object.
myannot <- simdat$annot   # Transcript and gene Identifiers for the above data.
```

With our emulated Sleuth object and annotation at hand (or your real data, if you have any readily available), 
we can now call DTU using `rats`. We will use default parameter values for everything. For details on
what parameters are available and how to use them, refer to the "Advanced input options" section.

```{r}
# Find DTU between conditions "controls" and "patients" in the simulated data.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", name_B = "patients", 
                  varname= "condition", verbose= FALSE,
                  description="Using a simulated sleuth object for the purposes of the tutorial.
                               Simulated using built-in functionality of `rats`.")
```

`call_DTU()` takes 5 mandatory arguments for this input format: 

1. an annotation data frame, as described in the Input section.
2. a sleuth object.
3. `name_A` and `name_B` are restricted to values available in `myslo$sample_to_covariates`. The values must both exist in the column specified by `varname`.
4. `varname` must be an existing column header in `myslo$sample_to_covariates`.

`description` is optional meta-data that will be recorded in the results object.
Its value can also be added after the run, by editing the relevant field of the returned object's `Parameters` element.

Please note that, unlike the other two usage cases, `name_A`, `name_B` and `varname` are **not optional**, as they specify how data is extracted from the Sleuth object.

Our simulated data also has a variable called `batch`, with values "ba" and "bb", so if we wanted to compare samples by batch
instead of condition we would do it like this:

```{r}
# See available variables and values.
print( myslo$sample_to_covariates )
```

```{r eval=FALSE}
# Compare samples by a non-default variable.
mydtu <- call_DTU(annot= myannot, slo= myslo, name_A= "ba", name_B= "bb", varname= "batch")
```

Please note that currently only one covariate is used in each run. therefore, any comparison you may wish to make must
be encoded as a single column in `myslo$sample_to_covariates`, by modifying the table if necessary.


***


## Quick results

For your convenience, `rats` provides a couple of functions to give you a quick summary of your results.
However, we do recommend you become familiar with the actual results structure and content, so that you
can judge the quality of the DTU calls and trace the reasons behind the classification of each gene or transcript.

The `dtu_summary()` function lists the number of genes and transcripts for each of the following 3 categories:

* DTU:  There is significant change in relative transcript abundance.
* non-DTU:  No significant change.
* NA:  Not applicable. Genes/transcripts with no/low fragment counts, or where the gene has only one transcript.

```{r}
# A really simple tally of the outcome.
print( dtu_summary(mydtu) )
```

The `get_dtu_ids()` function lists the actual identifiers per category, instead of the numbers in each category.
The categories are the same as those in `dtu_summary()` above.

```{r}
# Gene and transcript IDs corresponding to the tally above.
ids <- get_dtu_ids(mydtu)

# Contents
print( names(ids) )

# DTU positive genes.
print( ids[["dtu-genes"]] )
```

The ID lists obtained with the method shown above are ordered by effect magnitude (`Dprop`).


***


## Output structure

The output of `rats` is a list containing 4 elements:

```{r}
print( names(mydtu) )
```


### Parameters

`Parameters` is a list that contains information about the data and the settings.

```{r}
# Parameter list's elements.
print( names(mydtu$Parameters) )
```

1. `var_name` - (str) The name of the variable by which the samples were grouped. This is a column name in the `myslo$sample_to_covariates` table.
2. `cond_A` and `cond_B` - (str) The names of the two groups of samples to compare. These are values of the column specified above.
3. `num_replic_A` and `num_replic_B` - (int) The number of samples in each group.
4. `p_thresh` - (num) The significance level at which DTU is called, applicable to both tests.
5. `count_thresh` - (num) The minimum required fragment count per sample for each transcript.
6. `dprop_thresh` - (num) The minimum difference in proportion that is considered biologically significant.
7. `conf_thresh` - (num) Confidence threshold. The fraction of bootstrap iterations that must agree on the given outcome.
8. `tests` - (str) Which of the two tests (gene-wise, transcript-wise) were carried out.
9. `bootstrap` - (str) Which of the two tests (gene-wise, transcript-wise) was bootstrapped.
10. `bootnum` - (int) The number of bootstrap iterations.
11. `data_type` - (str) The format of the input data.
12. `num_genes` - (int) The number of genes in the provided annotation.
13. `num_transc` - (int) The number of transcripts in the provided annotation.
14. `description` - (str) Free-text description of the run. It is useful to record data sources, annotation source and version, experimental parameters...
15. `rats_version` - (str) The version of the package.
16. `R_version` - A list with the details of the R version.

### Genes

`Genes` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
results at the gene level.

The G-test is used for gene-level calls. *As the test is designed for comparison of a set of counts
against a **theoretical** set of proportions and, instead, we have two sets of counts, the test is run using
in turn each condition as reference for the proportions.* Thus, the table contains two sets of results,
marked with the "AB" and "BA" suffixes. Due to the nature of the test, it is not possible to attribute 
the change to specific transcripts within the gene, but in return the test has a lower detection threshold and 
will pick up smaller changes. It is possible to get a DTU-positive result here, even when all the individual transcripts
are predicted as DTU-negative.

```{r}
# Genes table's fields.
print( names(mydtu$Genes) )
```

1. `parent_id` - (str) The identification code for the gene.
2. `DTU` - (bool) The gene collectively shows DTU. Calculated as: `DTU = (sig & elig_fx & conf)`.
3. `transc_DTU` - (int) Aggregated from transcript-level DTU calls. Signifies that at least one transcript has changed significantly. Look up the gene in the `Transcripts` table to see which transcripts are responsible.
4. `known_transc` - (int) The number of known isoforms of the gene, according to the provided annotation.
5. `detect_transc` - (int) The number of annotated isoforms with non-zero expression in at least one of the two conditions: `known_transc >= detect_transc`.
6. `elig_transc` - (int) The number of detected isoforms that passed pre-filtering: `detect_transc >= elig_transc`. See the `Transcripts` table info below for details on how these are determined.
7. `elig` - (bool) Eligible for testing: By definition, a gene needs at least 2 expressed isoforms in order for DTU to even be possible: `elig = (elig_transc >= 2)`.
8. `elig_fx` - (bool) Eligible effect size: At least one of the transcripts shows eligible effect size (see `Transcripts` table explanations).
9. `pvalAB` and `pvalBA` - (num) The raw P-values from the G tests, using in turn each condition as reference.
10. `pvalAB_corr` and `pvalBA_corr` - (num) The above P-values adjusted for multiple testing (number of tested genes).
11. `sig` - (bool) Statistically significant: `sig = (pvalAB_corr < Parameters$p_thresh  &  pvalBA_corr < Parameters$p_thresh)`.
12. `boot_dtu_freq` - (num) The fraction of bootstrap iterations in which the gene was called DTU. It can be used as a 
measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
13. `conf` - (bool) Whether `boot_dtu_freq` meets the confidence threshold: `conf = (boot_dtu_freq >= Parameters$conf_thresh)` for DTU positive calls, and `conf = (boot_dtu_freq <= 1 - Parameters$conf_thresh)` for DTU negative calls.
14. `boot_p_meanAB` and `boot_p_meanBA` - (num) Mean P-values across the bootstraps.
15. `boot_p_stdevAB` and `boot_p_stdevBA` - (num) Standard deviations of the mean P-values across the bootstraps.
16. `boot_p_minAB` and `boot_p_minBA` - (num) The minimum (most significant) P-values that occurred in the bootstraps.
17. `boot_p_maxAB` and `boot_p_maxBA` - (num) The maximum (least significant) P-values that occurred in the bootstraps.
18. `boot_na` - (num) The fraction of bootstrap iterations in which the gene was not eligible for DTU calling.

**Note:** The fields reporting on the bootstraps will not be shown when bootstrapping is disabled.


### Transcripts

`Transcripts` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
results at the transcript level. For your convenience, the gene-level DTU calls are also included here.

The proportions test is used for the transcript-level calls. Changes can be attributed to specific transcripts,
but, as it uses less information, the test has a higher detection threshold and requires larger changes than the gene-level test.

```{r}
# Transcripts table's fields.
print( names(mydtu$Transcripts) )
```

1. `target_id` and `parent_id` - (str) The identification code for the transcript and gene, respectively.
2. `DTU` - (bool) The transcript's proportion changed significantly. Calculated as: `DTU = (sig & elig_fx & conf)`.
3. `gene_DTU` - (bool) Expanded from `Genes$DTU`. Indicates that the gene as a whole shows significant change in isoform proportions.
4. `meanA` and `meanB` - (num) The mean of counts across samples, for each condition.
5. `stdevA` and `stdevB` - (num) The standard deviation of the mean counts across samples, for each condition.
6. `sumA` and `sumB` - (num) The sum of counts across samples for each condition. This is used for the tests, so that replication level informs significance.
7. `totalA` and `totalB` - (num) The total counts for the gene: `totalA = sum(sumA); totalB= sum(sumB)  # by gene`.
8. `elig_xp` - (bool) Eligible expression level. A fragment count above the defined threshold in at least one of the two conditions is required: `elig_xp = (meanA > Parameters$count_thresh | meanB > Parameters$count_thresh)`.
9. `elig` - (bool) Eligible for testing. A transcript needs to meet the eligible expression level and its gene needs to have at least two expressed transcripts (by DTU definition), and finally the gene as a whole needs to have detectable 
expression in **both** conditions (otherwise the proportion cannot be defined): `elig = (elig_xp & totalA != 0 & totalB != 0 & (sumA != totalA | sumB != totalB))`
10. `propA` and `propB` - (num) The proportion of the gene expression owed to this transcript, in each condition.
11. `Dprop` - (num) The difference in the proportion of the transcript between the two conditions (biological effect).
12. `elig_fx` - (bool) Eligible effect size: Proxy for biological significance: `elig_fx = (Dprop > Parameters$dprop_thresh)`.
13. `pval` - (num) The raw P-value of the proportions test for the transcript.
14. `pval_corr` - (num) The above P-value adjusted for multiple testing (number of transcripts).
15. `sig` - (bool) Statistically significant: `sig = (pval_corr < Parameters$p_thresh)`.
16. `boot_dtu_freq` - (num) The fraction of bootstrap iterations in which the transcript was called DTU. It can be used as 
a measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
17. `conf` - (bool) Whether `boot_dtu_freq` meets the confidence threshold: `conf = (boot_dtu_freq >= Parameters$conf_thresh)` for DTU positive calls, and `conf = (boot_dtu_freq <= 1 - Parameters$conf_thresh)` for DTU negative calls.
18. `boot_p_mean` - (num) The mean P-value across the bootstraps.
19. `boot_p_stdev` - (num) The standard deviation of the mean P-value across the bootstraps.
20. `boot_p_min` - (num) The minimum (most significant) P-value that occurred in the bootstraps.
21. `boot_p_max` - (num) The maximum (least significant) P-value that occurred in the bootstraps.
22. `boot_na` - (num) The fraction of bootstrap iterations in which the transcripts were not eligible for DTU calling.

**Note** The fields reporting on the bootstraps will not be shown when bootstrapping is disabled.

### ReplicateData
 
`ReplicateData` is a list of two `data.table`s, one for each condition. Each table contains the actual counts used in the statistical tests for DTU.
Each transcript gets a single counts value per replicate, so if bootstrapped data was used, the values are the means across iterations. Otherwise, the values 
are essentially the input.


```{r}
# Elements of ReplicateData
print( names(mydtu$ReplicateData) )
```

1. `condA` - (num) The averaged counts across bootstraps, for eash transcript and replicate in the first condition.
2. `condB` - (num) The averaged counts across bootstraps, for eash transcript and replicate in the other condition.


<!-- *** -->


<!-- ## Example results -->

<!-- Now that you know what all the fields are, let's see how they apply to our simulated data. -->

<!-- ```{r} -->
<!-- # Let's check the info and settings. -->
<!-- print( mydtu$Parameters ) -->
<!-- ``` -->

<!-- * We're comparing samples by "`r mydtu$Parameters[["var_name"]]`", and the two values of that are "`r mydtu$Parameters[["cond_A"]]`"  -->
<!-- (with `r mydtu$Parameters[["num_replic_A"]]` samples) and "`r mydtu$Parameters[["cond_B"]]`" (with `r mydtu$Parameters[["num_replic_B"]]`  -->
<!-- samples).  -->
<!-- * The significance threshold is set to `r mydtu$Parameters[["p_thresh"]]`, the minimum count per sample is set to  -->
<!-- `r mydtu$Parameters[["count_thresh"]]` fragments and the proportion has to change by at least `r mydtu$Parameters[["dprop_thresh"]]`  -->
<!-- to be considered biologically significant. We require at least `r mydtu$Parameters[["conf_thresh"]]` of bootstrap iterations to agree -->
<!-- on the call. -->
<!-- * Are we doing gene-level or transcript-level tests: `r mydtu$Parameters[["tests"]]`. -->
<!-- * Are we bootstrapping the gene-level or transcript-level tests: `r mydtu$Parameters[["bootstrap"]]`. And we're  -->
<!-- doing `r mydtu$Parameters[["bootnum"]]` iterations. -->
<!-- * We used version "`r mydtu$Parameters[["rats_version"]]`" of the RATs package, and version "`r mydtu$Parameters$R_version$version.string`" -->
<!-- of the R engine. -->


<!-- ```{r} -->
<!-- # Gene-level calls. -->
<!-- print( mydtu$Genes ) -->
<!-- ``` -->

<!-- There are `r dim(mydtu$Genes)[1]` genes in the annotation used. Here are some possible scenarios: -->

<!-- * `1A1N` has only one known transcript and is thus not eligible. If you look in `myslo$kal[[1]]$bootstrap[[1]]`, there  -->
<!-- are actually two recorded transcripts for this gene, but only one of them is recorded in the annotation. `rats` uses  -->
<!-- the annotation as the basis for managing information. Any transcripts/genes present in the sleuth data, but missing from  -->
<!-- the annotation, will be ignored completely. -->
<!-- * `1B1C` has two annotated transcripts. If you look in `myslo$kal[[1]]$bootstrap[[1]]`, only one of them is recorded in  -->
<!-- our data whereas the other is missing completely, so the gene does not have enough transcripts to be eligible. -->
<!-- * `1D1C` has two transcripts, but only one was detected in our data, so it too is not eligible. Both transcript are  -->
<!-- present in the sleuth data, but one of them has zero counts in both conditions. Thus this gene is also not eligible.  -->
<!-- * `CC` has two known transcripts, both of which are detected and eligible, therefore it is eligible for DTU. It is  -->
<!-- significant, with eligible effect size, however it is not called as DTU. The bootstraps show that the calls -->
<!-- were less than 95% positive, thus it fell short of the confidence threshold. -->
<!-- * `LC` has two known transcripts, both of which are detected but only one of them is eligible, so it is not eligible for  -->
<!-- testing at the gene level. An inspection of the `Transcripts` table shows that the reason is that one of the two  -->
<!-- transcripts does not meet the minimum fragment count requirement. -->
<!-- * `MIX6` has six transcripts, 5 of which are detected and eligible. The gene is called as DTU with extremely high  -->
<!-- significance and all the bootstrap iterations were positive. Inspection of the `Transcripts` table shows that the  -->
<!-- missing transcript is not detected in either condition. -->
<!-- * `NIB`  has a single transcript that is not detected. Looking into `myslo$kal[[1]]$bootstrap[[1]]` it is evident that  -->
<!-- the entire gene is not recorded at all in the data. -->
<!-- * `NN` has two transcripts, both of which are detected and eligible, but no significant change is detected, a result -->
<!-- backed up by all the bootstrap iterations. -->
<!-- * `ALLA` has one transcript and it is detected in only one of the conditions, but one transcript is not enough to be eligible. -->
<!-- * `ALLB` has two transcripts, both detected, yet is still not eligible as both transcripts are not eligible. Inspection of -->
<!-- `Transcripts` shows that neither transcript is  detected in one of the conditions. Although the gene would likely be called as -->
<!-- DTE and DGE by the appropriate tools, it is not possible to define proportions in that condition, so it is not possible  -->
<!-- to call DTU for it. -->

<!-- **Note:** The values shown in the bootstrap columns will differ in each run of the same command, especially for few iterations, -->
<!-- due to random sampling. -->

<!-- ```{r} -->
<!-- # Transcript-level calls. -->
<!-- print( mydtu$Transcripts ) -->
<!-- ``` -->

<!-- Several mentions of this table were made during analysis of the `Genes` table. Here are some possible scenarios: -->

<!-- * `CC_a` and `CC_b` both show counts above the threshold, so they are eligible. They are significant, with eligible effect size, -->
<!-- but they fall short of the confidence threshold. This may be because the change in proportion is only marginally above the already  -->
<!-- quite permissive threshold. -->
<!-- * `LC1` and `LC2` both change in proportion above the threshold, but `LC1` does not meet the counts threshold.  -->
<!-- `LC2` is eligible for transcript-wise testing and comes out as non-DTU. The confidence threshold is set to 95% bootstrap agreement,  -->
<!-- so this call is not considered confident enough (only 87% = 100% - 13%). Gene-level DTU cannot be called since `LC1` did not meet all  -->
<!-- the criteria, leaving the gene with insufficient eligible transcripts. -->
<!-- * `MIX.c1`, `MIX.c2` and `MIX.c4` all show significant individual change. `MIX.c3`, despite statistical significance, -->
<!-- does not meet the effect size threshold and is thus called non-DTU. `MIX.nc` shows no significant change. `MIX6.d` is  -->
<!-- not detected at all. -->
<!-- * `1NN` and `2NN` do not show any change. -->
<!-- * `NIB.1` is not detected at all. In fact the entire gene is not detected (since this is the only transcript of the gene). Therefore -->
<!-- it is not possible to calculate anything for this gene/transcript, leading to `NA` in this row. -->
<!-- * `ALLA1` and `ALLB1`/`ALLB2` are similar in that they are detected in one condition only. Proportions cannot be defined for  -->
<!-- the other condition (division by 0), so they are not eligible for testing. -->



***


## Visualisation of results


The output object's tables provide a host of information. The `rats` package also includes some basic visualisation aides.


### Plot isoform abundance changes

This function allows you to visualise what's going on in any particular gene. Both the absolute counts and the relative 
proportions are plotted for each transcript. 
This is a very handy function for inspecting genes that have been called DTU. It enables quick visual evaluation of
the dispersion of the measurements, the magnitude of the change and the presence of outliers that may skew the DTU call.

```{r}
# Proportion and count changes for all the transcripts of the "MIX6" gene.
plot_gene(mydtu, "MIX6", style="lines")  # default
```

Several styles of this plot are available. The recommended style is set as default. The other options represent older 
styles that have been kept for backwards compatibility, but may get deprecated eventually: 

```{r eval=FALSE}
plot_gene(mydtu, "MIX6", style="points")
plot_gene(mydtu, "MIX6", style="rainbow")
plot_gene(mydtu, "MIX6", style="merged")
plot_gene(mydtu, "MIX6", style="dashed")
```


### Plots of overall run

Our simulated dataset is too small to properly demonstrate what these plots typically would look like.
So each one is accompanied by an image of the same plot created with a real and much larger dataset.

Several of these plots are **likely to display warnings** about missing or non-finite values. These are due to the 
presence of `NA` in the tables, where entries did not pass the thresholds, and can be ignored.

Possibly the most common plot in differential expression is the volcano plot, which plots the effect size against 
the statistical significance. As it is difficult to define a single p-value and a single effect size at the gene level,
the volcano can only be plotted at the transcript level.

```{r eval=FALSE}
# Proportion change VS significance.
plot_overview(mydtu, type="volcano")
```

This is what it looks like on a larger dataset:
![Dprop VS sig](./fig/volcano.jpg)

The next command plots the largest change in proportion seen within each gene, against the number of genes showing 
such change. This is a way to inspect what effect sizes are present in the data. As an additional layer of information,
they are colour-coded by their DTU call.

```{r eval=FALSE}
# Distribution of maximum proportion change.
plot_overview(mydtu, type="maxdprop")
```

This is what it looks like on a larger dataset:
![Max Dprop](./fig/maxdprop.jpg)


### Plot customisation

You can save any of the plots as a `ggplot2` object and use [ggplot2](http://ggplot2.org) manipulations on it, such as changing the axis scales.
Other `ggplot2` customisations include the axis tick marks, axis values, labels, titles, colours... Consult the [ggplot2](http://ggplot2.org)
documentation for more help on these.

```{r}
library(ggplot2)

myplot <- plot_overview(mydtu, "volcano")
myplot  # display

# Change title. 
myplot2 <- myplot + ggtitle("My epic title")
myplot2
```


### Interactive plots

The volcano plot and the isoform abundance change plots mentioned above are also available through a `shiny` app. This is a way to
explore your data visually and identify interesting transcripts.

1. By hovering over points on the volcano plot in the app, you can see the respective transcript identifier(s). 
2. Clicking will pull up information on the effect size, significance and confidence of the point(s), as well as 
the respective isoform abundance changes plot for the point nearest to the click.

```{r eval=FALSE}
# Start the interactive volcano plot.
plot_shiny_volcano(mydtu)
```

This is what it looks like for the example data (remember that the emulated data example has very few transcripts).

![Transc Conf VS DTU](./fig/shiny_screenshot.png)


You will need to close down the app to return to your R terminal.


***


## Advanced options

In summary, `rats` works as follows:

![RATs design](./fig/RATs_decisions.png)


### Thresholds

Four thresholds can be set in `rats`.

```{r eval=FALSE}
# Calling DTU with custom thresholds.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", name_B = "patients", 
                  p_thresh = 0.01, count_thresh = 10, dprop_thresh = 0.25)
```

1. `p_thresh` - Significance level. P-values below this will be considered significant. 0.05 is a very permissive value.
2. `count_thresh` - At least one of the two conditions needs to exceed this number of fragments per sample for the transcript 
to be considered. Low counts have high uncertainty and low significance. Removing such entries from the analysis when both 
conditions are low-count improves the confidence in the predictions of the remaining transcripts, and reduces 
computation time. The reason this threshold requires only one condition to meet it is that enforcing it on both conditions 
would erroneously disqualify transcripts that may be silenced in one of the two conditions but highly expressed in the other.
3. `dprop_thresh` - This is a proxy for biological significance. A transcript's proportion must change by at least this much 
for it to be considered. The need for this is due to the fact that high counts will make even minute differences show up as 
statistically significant, however very small changes are likely to be biologically indifferent.
4. `conf_thresh` - Confidence threshold. Only applies when bootstraps are enabled. It sets the fraction of bootstrap iterations
that support the DTU call that are required to consider the call confident.

The default values for the first three thresholds are rather lenient. You may want to set them to stricter values, as they generally produce
many positive calls. The fourth threshold is set to a rather strict value. You can visualise its effect using
the plotting function discussed later in the section about bootstrapping.


### Comparing by different variables

So far, we've mostly compared conditions (`myslo$sample_to_covariates[["condition"]]`). Your data could contain other 
variables as well. As we saw in a previous example, our simulated data contains a variable called `batch`, with values
"ba" and "bb", according to the `myslo$sample_to_covariates` table.

```{r}
# Compare by a different variable. In this case "batch".
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "ba", name_B = "bb", 
                  varname= "batch", verbose = FALSE)
```


### Bootstrapping & Confidence in DTU calls

Bootstrapping of the DTU calls is enabled by default and their results were already discussed in the section
about output structure and the example results. Bootstrapping prolongs processing time considerably, 
but it provides a **measure of confidence in the p-values**, so we think it is important. 

Current transcript quantification algorithms such as [kallisto](https://pachterlab.github.io/kallisto/about), 
[salmon](https://combine-lab.github.io/salmon/) and [sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/) use 
probabilistic approaches to estimate transcript abundance. They all have the option to bootstrap their quantifications,
as required by Sleuth. We use these bootstrapped abundance estimations to control for the effect that
the variability in these quantifications has on the DTU calls.

Two parameters control bootstrapping of DTU calls on the abundance estimates:

1. `boots` - Although we recommend bootstrapping both gene-level and transcript-level DTU calls, dropping one would reduce
computation time, so the option is provided to allow flexibility for special use cases.
2. `bootnum` - Generally, greater is better but it takes longer. This parameter needs to be sensible with regards
to the number of quantification bootstraps available in the input data, with a rule-of-thumb upper limit being the number
of quantification iterations. There is currently also a hard upper limit as a result of R's maximum allowed matrix size.
If the value is 0 (default), `rats` will auto-detect the number of iterations in the input data.

Warnings will be generated if `bootnum` is below 100 or higher than the number of iterations in your input data. The warnings
will not be shown if `verbose =  FALSE`.

```{r eval=FALSE}
# Bootstrap both types of DTU calls (default), for 100 iterations (default).
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "both", bootnum = 100)

# Only bootstrap transcript calls.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "transc")

# Only bootstrap gene calls.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "genes")

# Skip bootstraps.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "none")
```

As measure of confidence in the DTU calls, we take the fraction of the bootstrap iterations that agrees with that call.
So a positive call is confident if `>= conf_thresh` and a negative call is confident if `<= 1 - conf_thresh`.
The default confidence threshold can be overridden.

```{r eval=FALSE}
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", conf_thresh = 0.99)
```

**IMPORTANT:** Due to the nature of random sampling, the confidence value can still fluctuate from one run to the next, 
even if the input data is identical. This can lead to differences in the set of DTU genes/transcripts between runs. 
These inconsistencies can be reduced by doing more bootstrap iterations, both in `rats` and in your chosen quantification tool.

The effect of the confidence threshold in a particular run, can be visualised by plotting the number of positive DTU calls
against the threshold.

```{r eval=FALSE}
# Transcript-level confidence threshold VS. number of DTU positive calls.
plot_overview(mydtu, type="transc_conf")

# Gene-level confidence threshold VS. number of DTU positive calls.
plot_overview(mydtu, type="gene_conf")
```

This is what either of these plots looks like on a larger dataset:
![Transc Conf VS DTU](./fig/transc_conf.jpg)


### Test selection

`rats` runs gene-level calls (slower, lower detection threshold, less fine-grained) and transcript-level calls 
(faster, higher detection threshold, more fine-grained). They are complementary and we recommend using them
together, but the option to skip either is provided for special use cases. 
The fields of the skipped test will be filled with `NA`.

```{r eval=FALSE}
# Transcripts only.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", testmode="transc")
# Genes only.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", testmode="genes")
```


### Correction for multiple testing

Testing multiple null hypotheses increases the chance of one being falsely rejected. To keep the overall false rate at the 
desired level, the raw p-values must be adjusted. The default adjustment 
method is `BH` (Benjamini-Hochberg). A full list of options is listed in R's `p.adjust.methods`.

```{r eval=FALSE}
# Bonferroni correction.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", correction = "bonferroni")
```


### Multi-threading

RATs runtime depends on the number of expressed annotated transcripts. Single-threaded, RATs can take a few minutes per iteration for large annotations.
Fortunately, the task is highly parallelisable:

```{r eval=FALSE}
# Using 8 threads/cores for parallel computing.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", threads = 8)
```

Due to core R implementation limitations, multi-threading works only in POSIX-compliant systems. In other systems, the option will be ignored and R will run serially.
Most Linux distros, Unix versions, and recent OSX versions are supposedly compatible, and there are environments that can be installed on Windows.


### Input structure flexibility

`rats` needs to pull information from different fields of the data and annotation. You can 
override the names of these fields.

```{r}
# Lets emulate some input with custom field names. 
sim <- sim_sleuth_data(varname="mouse", cnames=c("Splinter", "Mickey"), 
                       COUNTS_COL="the-counts", TARGET_COL="transcript", 
                       PARENT_COL="gene", BS_TARGET_COL = "trscr")
myslo <- sim$slo
myannot <- sim$annot

print( sim$slo$sample_to_covariates )
print( head(sim$slo$kal[[1]]$bootstrap[[1]]) )
print( head(sim$annot) )
```

With the field names changed, we need to tell `rats` where to find the data:

```{r}
# Call DTU on data with custom field names.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "Splinter", name_B = "Mickey", 
                  varname="mouse", TARGET_COL="transcript", PARENT_COL="gene", 
                  COUNTS_COL="the-counts", BS_TARGET_COL="trscr", verbose = FALSE)
```

The output structure will always use the same field names, regardless of what the input field names are.

```{r}
print( names(mydtu$Transcripts) )
```

* `varname` - The field name in `myslo$sample_to_covariates` where the desired condition names are listed.
* `TARGET_COL` - The name of the field holding the transcript identifiers in the annotation data frame.
* `PARENT_COL` - The name of the field holding the respective gene identifiers in the annotation data frame.
* `COUNTS_COL` - The name of the field holding the estimated counts in the sleuth object's bootstrap tables.
* `BS_TARGET_COL` - The name of the field holding the transcript identifiers in the sleuth object's bootstrap tables.


***


## Annotation discrepancies

Different annotation versions often preserve transcript IDs, despite altering the details of the transcript models,
such as UTRs. It is important to use the same annotation throught the workflow, especially for the quantifications.
Otherwise, the data is not comparable.

All internal operations and the output of RATs will be based on the annotation provided:

* Any transcripts/genes present in the data but missing from the annotation will be ignored completely and 
will not show up in the output, as there is no reliable way to match them to gene IDs.
* Any transcript/gene present in the annotation but missing from the data will be included in the output as zero expression.
* If the samples appear to use different annotations from one another, `rats` will abort.


***


# Contact information

The rats R package was developed within [The Barton Group](http://www.compbio.dundee.ac.uk) at [The University of Dundee](http://www.dundee.ac.uk)
by Dr. Kimon Froussios, Dr. Kira MourÃ£o and Dr. Nick Schurch.

To **report problems** or **ask for assistance**, please raise a new issue [on the project's support forum](https://github.com/bartongroup/Rats/issues).
Providing a *reproducible working example* that demonstrates your issue is strongly encouraged to help us understand the problem. Also, be sure 
to **read the vignette(s)**, and browse/search the support forum before posting a new issue, in case your question is already answered there.

Enjoy!

![](./fig/rats.png)

