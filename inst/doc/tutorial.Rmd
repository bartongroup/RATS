---
title: "RATs Tutorial"
author: "Kimon Froussios"
date: "01 SEP 2016"
output: 
  html_document: 
    fig_caption: no
    keep_md: yes
    theme: readable
    toc: yes
abstract: >
  The [rats](http://github.com/bartongroup/Rats) package is aimed at people analysing **gene expression** and **transcript abundance**, 
  particularly with **RNA-Seq** type of data in mind. This vignette constitutes the main 
  documentation for the package.
vignette: >
  %\VignetteIndexEntry{RATs Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


# Relative Abundance of Transcripts (RATs).

The `rats` R package aims to identify genes that show a shift in the relative abundance of their transcript isoforms 
between two conditions (*Differential Transcript Usage* -- **DTU**). This is supplementary
to identifying *Differential Transcript Expression* (**DTE**), which simply measures whether transcripts change in
abundance, but does not compare them to their sibling isoforms within each gene. Situations that show DTU are a 
subset of those that show DTE. The figure below shows the relationship between DTU and DTE, as well as between them and
*differential gene expression* (**DGE**):

![DGE vs. DTE vs. DTU](./fig/dge-dte-dtu.jpg)



# Quick start.


```{r eval=FALSE}
# 1. Build latest developmental version from Github:
devtools::install_github("bartongroup/rats")

# 2. Load into R session.
library{rats}

# 3. Specify transcript grouping:
my_identifiers_table <- annot2ids("my_annotation.gtf")

# 4a. Call DTU on a sleuth object, using default settings:
mydtu <- call_DTU(annot= my_identifiers_table, slo= my_sleuth_object, 
                  name_A= "My_condition", name_B= "My_other_condition")
# 4b. Call DTU on generic bootstrapped abundance estimates:
mydtu <- call_DTU(annot= my_identifiers_table, boot_data_A= my_list_data_tables_A, 
                  boot_data_B= my_list_data_tables_A)
# 4c. Call DTU on generic abundance estimates:
mydtu <- call_DTU(annot= my_identifiers_table, count_data_A= my_data_table_A, 
                  count_data_B= my_data_table_B, boots= "none")

# 5. Get all gene and transcript identifiers per category (significant DTU, 
# no DTU, Not Applicable):
myids <- get_dtu_ids(mydtu)

# 6. Plot significance VS effect size:
plot_overview(mydtu)
```

The input and output structures and the command options are discussed in more detail in the rest of this tutorial.


# Installation and loading

### Install dependencies first

`install.packages(c("data.table", "matrixStats", "ggplot2"), dependencies=TRUE)`

If you have trouble installing these dependencies, your system could be missing source compilers for C and/or Fortran, and possibly other libraries, which you can see by scrolling back through the output to look for the errors. Please refer to the R manual for help.


### Install latest release

#### from Github

Available as R source package form from the [releases section](https://github.com/bartongroup/Rats/releases) on Github.
Download the latest release and then install it using:

`install.packages("<path/to/dowloaded/package>", repos = NULL, type="source")`

#### through Bioconductor

Not available yet.


### Install latest developmental version from Github

The most current `rats` can be installed directly, using the [devtools](https://www.rstudio.com/products/rpackages/devtools/) package:

`devtools::install_github("bartongroup/rats")`

This way might not install the vignettes and the version may also contain more bugs.


### Loading

Once installed, rats is imported into your r session as normal:

```{r}
library(rats)
```

# The package in detail

## Input formats

### Data

`rats` can work with any of three input types:

1. A [Sleuth](http://pachterlab.github.io/sleuth/) object.
2. Generic bootstrapped abundance estimates.
3. Generic abundance estimates.

From a [Sleuth](http://pachterlab.github.io/sleuth/) object `rats` extracts the bootstrapped abundance estimates. See the 
[introduction to Sleuth](http://rawgit.com/pachterlab/sleuth/master/inst/doc/intro.html) pages for details on how 
to load the transcript abundance estimate data from [Kallisto](http://pachterlab.github.io/kallisto/) into a Sleuth 
object, and see the [wasabi](http://github.com/COMBINE-lab/wasabi) tool for how to load the transcript abundance 
estimate data from [Sailfish](http://github.com/kingsfordgroup/sailfish) or [Salmon](https://github.com/COMBINE-lab/salmon) 
into a sleuth object.

Bootstrapped abundance estimates obtained by other means can be input as `list`s of `data.table`s. Two lists are needed, one per condition.
Each data table should contain the transcript identifiers in the first column, followed by columns containing the estimates from the bootstrap iterations:

```{r}
# Show the first rows of the table corresponding to one sample, from simulated data.
head(sim_boot_data()[[2]][[1]])
```

Generic abundance estimates, without bootstrapping information, can be input simply as two `data.table`s, one per condition. The first column should
contain the transcript identifiers, followed by columns listing the abundance per sample. The format of each table is identical to the one shown above,
only the meaning of the numbers changes.

### Annotation

**Regardless of data format**, `rats` also needs an annotation `data.frame` that matches transcript identifiers to gene identifiers. This looks like this:

```{r}
# Show the first rows of the table corresponding to the annotation, from simulated data.
head(sim_count_data()[[1]])
```

A function is provided to create this table, given a GTF file. **Note:** GFF3 is *not* supported, as the specification is too relaxed regarding identifiers.
Other ways to create such a table exist, for example using the [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html) interface, but they
are beyond the scope of this tutorial.

```{r eval=FALSE}
# Extract transcript ID to gene ID index from a GTF annotation.
myannot <- annot2ids("my_annotation_file.gtf")
```


## Calling DTU 

To bypass the complexity of running third-party tools in this tutorial, we will instead use **emulated data**. `rats` comes
with data emulators, intended to be used for testing the code. However, they are also convenient to use for showcasing
how `rats` works. If you happen to have real data available, go ahead and use that instead if you wish.

By default, `rats` reports on its progress and produces a summary report that has 3 categories for each of genes and transcripts (more on this, later):

* DTU - significant change in proportions.
* non-DTU - no significant changes.
* NA - The tests were not applicable (due to low/no fragment counts or lack of alternative transcripts).

The progress messages and summary can be suppressed by adding the `verbose = FALSE` parameter to the call. 
To prevent cluttering this tutorial, we will use this option in all the examples, but feel free to omit it.


### with generic abundance estimates, without bootstraps

This is the simplest usage case, provided only for completeness. We recommend using bootstrapped data whenever possible,
for reasons that will be discussed in the relevant section below.

First, let's emulate some data, as described in the Input section.

```{r}
# Simulate some data.
simdat <- sim_count_data()

# For convenience let's assign the contents of the list to separate variables.
mycond_A <- simdat[[2]]          # Simulated abundances for one condition.
mycond_B <- simdat[[3]]          # Simulated abundances for other condition.
myannot <- simdat[[1]]   # Transcript and gene Identifiers for the above data.
```

Now we can call DTU:

```{r}
# Find DTU between the simulated datasets.
mydtu <- call_DTU(annot= myannot, count_data_A= mycond_A, count_data_B= mycond_B, 
                  boots= "none", verbose= FALSE,
                  name_A= "healthy", name_B= "patients", varname= "My phenotype",
                  description="Comparison of two simulated counts datasets for the
                               tutorial. Simulated using built-in functionality of 
                               `rats`.")
```

`call_DTU()` takes 4 mandatory arguments for this input format. 

1. An annotation data frame, as described in the Input section.
2. `boots` must only take the value `"none"` in this case. It prevents `rats` from bootstrapping the DTU calls.
3. `count_data_A` and `count_data_B` are each a `data.table` as described in the Input section.

`name_A`, `name_B`, `varname` and `description` are optional meta-data that will be recorded in the results object.
Their values can also be added after the run, by editing the relevant fields of the returned object's `Parameters` element.


### with generic bootstrapped abundance estimates

First, we need data, as described in the Input section, so let's emulate some, as we did before.

```{r}
# Simulate some data.
simdat <- sim_boot_data()

# For convenience let's assign the contents of the list to separate variables.
mycond_A <- simdat[[2]]          # Simulated bootstrapped data for one condition.
mycond_B <- simdat[[3]]          # Simulated bootstrapped data for other condition.
myannot <- simdat[[1]]   # Transcript and gene Identifiers for the above data.
```

Now we can call DTU:

```{r}
# Find DTU between conditions "controls" and "patients" in the simulated data.
mydtu <- call_DTU(annot= myannot, boot_data_A= mycond_A, boot_data_B= mycond_B, 
                  name_A= "wildtype", name_B= "some mutant", varname = "My phenotype",
                  verbose= FALSE, description="Comparison of two simulated datasets 
                    of bootstrapped counts for the tutorial. Simulated using built-in 
                    functionality of `rats`.")
```

`call_DTU()` takes 3 mandatory arguments for this input format. 

1. An annotation data frame, as described in the Input section.
2. `boot_data_A` and `boot_data_B` are each a list of `data.table` objects, as described in the Input section.

`name_A`, `name_B`, `varname` and `description` are optional meta-data that will be recorded in the results object.
Their values can also be added after the run, by editing the relevant fields of the returned object's `Parameters` element.


### with a sleuth object

First, let's emulate a Sleuth object, using the bundled tools. The real Sleuth objects are quite large and very complex nested lists. 
The emulated one contains only the essential parts relevant to calling DTU with `rats`. It has a couple 
of bootstraps of transcript abundance estimates, for a handful of made-up genes, in two conditions.

```{r}
# Simulate some data.
simdat <- sim_sleuth_data(cnames = c("controls", "patients")) 
# controls and patients are arbitrary names to use as conditions.

# For convenience let's assign the contents of the list to separate variables.
myslo <- simdat$slo       # Simulated minimal sleuth object.
myannot <- simdat$annot   # Transcript and gene Identifiers for the above data.
```

With our emulated Sleuth object and annotation at hand (or your real data, if you have any readily available), 
we can now call DTU using `rats`. We will use default parameter values for everything. For details on
what parameters are available and how to use them, refer to the "Advanced input options" section.

```{r}
# Find DTU between conditions "controls" and "patients" in the simulated data.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", name_B = "patients", 
                  varname= "condition", verbose= FALSE,
                  description="Using a simulated sleuth object for the purposes of the tutorial.
                               Simulated using built-in functionality of `rats`.")
```

`call_DTU()` takes 5 mandatory arguments for this input format: 

1. an annotation data frame, as described in the Input section.
2. a sleuth object.
3. `name_A` and `name_B` are restricted to values available in `myslo$sample_to_covariates`. The values must both exist in the column specified by `varname`.
4. `varname` must be an existing column header in `myslo$sample_to_covariates`.

`description` is optional meta-data that will be recorded in the results object.
Its value can also be added after the run, by editing the relevant field of the returned object's `Parameters` element.

Please note that, unlike the other two usage cases, `name_A`, `name_B` and `varname` are **not optional**, as they specify how data is extracted from the Sleuth object.

Our simulated data also has a variable called "batch", with values "ba" and "bb", so if we wanted to compare samples by batch
instead of condition we would do it like this:

```{r}
# See available variables and values.
print( myslo$sample_to_covariates )
```

```{r eval=FALSE}
# Compare samples by a non-default variable.
mydtu <- call_DTU(annot= myannot, slo= myslo, name_A= "ba", name_B= "bb", varname= "batch")
```

Please note that currently only one covariate is used in each run. therefore, any comparison you may wish to make must
be encoded as a single column in `myslo$sample_to_covariates`, by modifying the table if necessary.


## Quick results

For your convenience, `rats` provides a couple of functions to give you a quick summary of your results.
However, we do recommend you become familiar with the actual results structure and content, so that you
can judge the quality of the DTU calls and trace the reasons behind the classification of each identifier.

The `dtu_summary()` function lists the number of genes and transcripts for each of the following 3 categories:

* DTU:  There is significant change in relative transcript abundance.
* non-DTU:  No significant change.
* NA:  Not applicable. Genes/transcripts with no/low fragment counts, or where the gene has only one transcript.

```{r}
# A really simple tally of the outcome.
print( dtu_summary(mydtu) )
```

The `get_dtu_ids()` function lists the actual identifiers per category, instead of the numbers in each category.
The categories are the same as those in `dtu_summary()` above.

```{r}
# Gene and transcript IDs corresponding to the tally above.
ids <- get_dtu_ids(mydtu)

# Contents
print( names(ids) )

# DTU positive genes.
print( ids[["dtu-genes"]] )
```


## Output structure

The output of `rats` is a list containing 3 elements:

```{r}
print( names(mydtu) )
```


### Parameters

`Parameters` is a list that contains information about the data and the settings.

```{r}
# Parameter list's elements.
print( names(mydtu$Parameters) )
```

1. `var_name` - The name of the variable by which the samples were grouped. This is a column name in the `myslo$sample_to_covariates` table.
2. `cond_A` and `cond_B` - The names of the two groups of samples to compare. These are values of the column specified above.
3. `num_replic_A` and `num_replic_B` - The number of samples in each group.
4. `p_thresh` - The significance level at which DTU is called, applicable to both tests.
5. `count_thresh` - The minimum required fragment count per sample for each transcript.
6. `dprop_thresh` - The minimum difference in proportion that is considered biologically significant.
7. `conf_thresh` - Confidence threshold. The fraction of bootstrap iterations that must agree on the given outcome.
8. `tests` - Which of the two tests (gene-wise, transcript-wise) were carried out.
9. `bootstrap` - Which of the two tests (gene-wise, transcript-wise) was bootstrapped.
10. `bootnum` - The number of bootstrap iterations.
11. `data_type` - The format of the input data.
12. `num_genes` - The number of genes in the provided annotation.
13. `num_transc` - The number of transcripts in the provided annotation.
14. `description` - Free-text description of the run. It is useful to record data sources, annotation source and version, experimental parameters...
15. `rats_version` - The version of the package.
16. `R_version` - A list with the details of the R version.

### Genes

`Genes` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
results at the gene level. For your convenience, the transcript-level DTU calls are also summarised here.

The G-test is used for gene-level calls. *As the test is designed for comparison of a set of counts
against a **theoretical** set of proportions and, instead, we have two sets of counts, the test is run using
in turn each condition as reference for the proportions.* Thus, the table contains two sets of results,
marked with the "AB" and "BA" suffixes. Due to the nature of the test, it is not possible to attribute 
the change to specific transcripts within the gene, but in return the test has a lower detection threshold and 
will pick up smaller changes.

```{r}
# Genes table's fields.
print( names(mydtu$Genes) )
```

1. `parent_id` - The identification name/code of the gene.
2. `DTU` - The gene collectively shows DTU, according to the gene-wise test. It is not possible to attribute 
this to specific transcripts. To be DTU, a gene needs both biological and statistical significance, as well as consistent
classification in the bootstraps: `DTU = (sig & elig_fx & conf)`.
3. `transc_DTU` - Aggregated from `Transcript$DTU`. Signifies that at least one transcript has changed significantly 
according to the transcript-wise test. Look up the gene in the `Transcripts` table to see which transcripts are responsible.
4. `known_transc` - The number of annotated transcripts for the gene.
5. `detect_transc` - The number of transcripts with non-zero expression in at least one of the two conditions. 
`known_transc >= detect_transc`.
6. `elig_transc` - The number of transcripts eligible for DTU calling. `detect_transc >= elig_transc`. See the 
`Transcripts` table info below for details on how these are determined.
7. `elig` - Eligible for testing: By definition, a gene needs at least 2 eligible transcripts in order for DTU to even be
possible.
8. `elig_fx` - Eligible effect size: At least one of the transcripts shows eligible effect size
(see `Transcripts` table explanations).
9. `pvalAB` and `pvalBA` - The raw P-values from the G tests, using in turn each condition as reference.
10. `pvalAB_corr` and `pvalBA_corr` - The above P-values adjusted for multiple testing (number of tested genes).
11. `sig` - Statistically significant: `pvalAB_corr < Parameters$p_thresh  &  pvalBA_corr < Parameters$p_thresh`.
12. `boot_dtu_freq` - The fraction of bootstrap iterations in which the gene was called DTU. It can be used as a 
measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
13. `conf` - Whether `boot_dtu_freq` meets the confidence threshold. `conf <- boot_dtu_freq >= Parameters$conf_thresh` for
DTU positive calls, and `conf <- boot_dtu_freq <= 1 - Parameters$conf_thresh` for DTU negative calls.
14. `boot_p_meanAB` and `boot_p_meanBA` - Mean P-values across the bootstraps.
15. `boot_p_stdevAB` and `boot_p_stdevBA` - Standard deviations of the mean P-values across the bootstraps.
16. `boot_p_minAB` and `boot_p_minBA` - The minimum (=most significant) P-values that occurred in the bootstraps.
17. `boot_p_maxAB` and `boot_p_maxBA` - The maximum (=least significant) P-values that occurred in the bootstraps.
18. `boot_na` - The fraction of bootstrap iterations in which the gene was not eligible for DTU calling.

**Note:** The fields reporting on the bootstraps will not be shown when bootstrapping is disabled.


### Transcripts

`Transcripts` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
results at the transcript level. For your convenience, the gene-level DTU calls are also included here.

The proportions test is used for the transcript-level calls. Changes can be attributed to specific transcripts,
but, as it uses less information, the test has a higher detection threshold and requires larger changes than the gene-level test.

```{r}
# Transcripts table's fields.
print( names(mydtu$Transcripts) )
```

1. `target_id` and `parent_id` - The identification name/code of the transcript and gene, respectively.
2. `DTU` - Whether the transcript's proportion changed significantly, according to the transcript-wise test.
To be DTU, a transcripts needs both biological and statistical significance, as well as consistent
classification in the bootstraps: `DTU = (sig & elig_fx & conf)`.
3. `gene_DTU` - Expanded from `Genes$DTU`. Indicates that the gene as a whole shows significant change in proportions.
4. `meanA` and `meanB` - The mean of counts across samples, for each condition.
5. `stdevA` and `stdevB` - The standard deviation of the mean counts across samples, for each condition.
6. `sumA` and `sumB` - The sum of counts across samples for each condition. This is used for the tests, so that a 
higher number of samples leads to higher significance.
7. `totalA` and `totalB` - The total counts for the gene. `totalA = sum(sumA)  # by gene`.
8. `elig_xp` - Eligible expression level: A fragment count above the defined threshold in at least one of the two 
conditions is required. `elig_xp = (meanA > Parameters$count_thresh | meanB > Parameters$count_thresh)`.
9. `elig` - Eligible for testing: A transcript needs to meet the eligible expression level and its gene needs to have 
more than one eligible expression transcripts (by DTU definition), and finally the gene as a whole needs to have detectable 
expression in **both** conditions (otherwise the proportion cannot be defined). `elig = (elig_xp & totalA != 0 & totalB != 0 & (sumA != totalA | sumB != totalB))`
10. `propA` and `propB` - The proportion of the gene expression owed to this transcript, in each condition.
11. `Dprop` - The difference in the proportion of the transcript between the two conditions.
12. `elig_fx` - Eligible effect size: Proxy for biological significance. Meaninglessly small changes in the
proportion can be statistically significant if transcript expression or sequencing depth are very high.
`elig_fx = (Dprop > Parameters$dprop_thresh)`.
13. `pval` - The raw P-value of the proportions test for the transcript.
14. `pval_corr` - The above P-value adjusted for multiple testing (number of transcripts).
15. `sig` - Statistically significant: `pval_corr < Parameters$p_thresh`.
16. `boot_dtu_freq` - The fraction of bootstrap iterations in which the transcript was called DTU. It can be used as 
a measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
17. `conf` - Whether `boot_dtu_freq` meets the confidence threshold. `conf <- boot_dtu_freq >= Parameters$conf_thresh` for
DTU positive calls, and `conf <- boot_dtu_freq <= 1 - Parameters$conf_thresh` for DTU negative calls.
18. `boot_p_mean` - The mean P-value across the bootstraps.
19. `boot_p_stdev` - The standard deviation of the mean P-value across the bootstraps.
20. `boot_p_min` - The minimum (most significant) P-value that occurred in the bootstraps.
21. `boot_p_max` - The maximum (most significant) P-value that occurred in the bootstraps.
22. `boot_na` - The fraction of bootstrap iterations in which the transcripts were not eligible for DTU calling.

**Note** The fields reporting on the bootstraps will not be shown when bootstrapping is disabled.



## Example results

Now that you know what all the fields are, let's see how they apply to our simulated data.

```{r}
# Let's check the info and settings.
print( mydtu$Parameters )
```

* We're comparing samples by "`r mydtu$Parameters[["var_name"]]`", and the two values of that are "`r mydtu$Parameters[["cond_A"]]`" 
(with `r mydtu$Parameters[["num_replic_A"]]` samples) and "`r mydtu$Parameters[["cond_B"]]`" (with `r mydtu$Parameters[["num_replic_B"]]` 
samples). 
* The significance threshold is set to `r mydtu$Parameters[["p_thresh"]]`, the minimum count per sample is set to 
`r mydtu$Parameters[["count_thresh"]]` fragments and the proportion has to change by at least `r mydtu$Parameters[["dprop_thresh"]]` 
to be considered biologically significant. We require at least `r mydtu$Parameters[["conf_thresh"]]` of bootstrap iterations to agree
on the call.
* Are we doing gene-level or transcript-level tests? `r mydtu$Parameters[["tests"]]`
* Are we bootstrapping the gene-level or transcript-level tests? `r mydtu$Parameters[["bootstrap"]]`. And we're 
doing `r mydtu$Parameters[["bootnum"]]` iterations.


```{r}
# Gene-level calls.
print( mydtu$Genes )
```

There are `r dim(mydtu$Genes)[1]` genes in the annotation used. Here are some possible scenarios:

* `1A1N` has only one known transcript and is thus not eligible. If you look in `myslo$kal[[1]]$bootstrap[[1]]`, there 
are actually two recorded transcripts for this gene, but only one of them is recorded in the annotation. `rats` uses 
the annotation as the basis for managing information. Any transcripts/genes present in the sleuth data, but missing from 
the annotation, will be ignored completely.
* `1B1C` has two annotated transcripts. If you look in `myslo$kal[[1]]$bootstrap[[1]]`, only one of them is recorded in 
our data whereas the other is missing completely, so the gene does not have enough transcripts to be eligible.
* `1D1C` has two transcripts, but only one was detected in our data, so it too is not eligible. Both transcript are 
present in the sleuth data, but one of them has zero counts in both conditions. Thus this gene is also not eligible. 
* `CC` has two known transcripts, both of which are detected and eligible, therefore it is eligible for DTU. It is 
significant, with eligible effect size, however it is not called as DTU. The bootstraps show that the calls
were less than 95% positive, thus it fell short of the confidence threshold.
* `LC` has two known transcripts, both of which are detected but only one of them is eligible, so it is not eligible for 
testing at the gene level. An inspection of the `Transcripts` table shows that the reason is that one of the two 
transcripts does not meet the minimum fragment count requirement.
* `MIX6` has six transcripts, 5 of which are detected and eligible. The gene is called as DTU with extremely high 
significance and all the bootstrap iterations were positive. Inspection of the `Transcripts` table shows that the 
missing transcript is not detected in either condition.
* `NIB`  has a single transcript that is not detected. Looking into `myslo$kal[[1]]$bootstrap[[1]]` it is evident that 
the entire gene is not recorded at all in the data.
* `NN` has two transcripts, both of which are detected and eligible, but no significant change is detected, a result
backed up by all the bootstrap iterations.
* `ALLA` has one transcript and it is detected in only one of the conditions, but one transcript is not enough to be eligible.
* `ALLB` has two transcripts, both detected, yet is still not eligible as both transcripts are not eligible. Inspection of
`Transcripts` shows that neither transcript is  detected in one of the conditions. Although the gene would likely be called as
DTE and DGE by the appropriate tools, it is not possible to define proportions in that condition, so it is not possible 
to call DTU for it.

**Note:** The values shown in the bootstrap columns will differ in each run of the same command, especially for few iterations,
due to random sampling.

```{r}
# Transcript-level calls.
print( mydtu$Transcripts )
```

Several mentions of this table were made during analysis of the `Genes` table. Here are some possible scenarios:

* `CC_a` and `CC_b` both show counts above the threshold, so they are eligible. They are significant, with eligible effect size,
but they fall short of the confidence threshold. This may be because the change in proportion is only marginally above the already 
quite permissive threshold.
* `LC1` and `LC2` both change in proportion above the threshold, but `LC1` does not meet the counts threshold. 
`LC2` is eligible for transcript-wise testing and comes out as non-DTU, with good support by the bootstraps.
Gene-level DTU cannot be called since `LC1` did not meet all the criteria, leaving the gene with insufficient eligible transcripts.
* `MIX.c1`, `MIX.c2` and `MIX.c4` all show significant individual change. `MIX.c3`, despite statistical significance,
does not meet the effect size threshold and is thus called non-DTU. `MIX.nc` shows no significant change. `MIX6.d` is 
not detected at all.
* `1NN` and `2NN` do not show any change.
* `NIB.1` is not detected at all. In fact the entire gene is not detected (since this is the only transcript of the gene). Therefore
it is not possible to calculate anything for this gene/transcript, leading to `NA` in this row.
* `ALLA1` and `ALLB1`/`ALLB2` are similar in that they are detected in one condition only. Proportions cannot be defined for 
the other condition (division by 0), so they are not eligible for testing.



## Visualisation of results


The output object's tables provide a host of information. The `rats` package also includes some basic visualisation aids.

### Plot individual abundance changes

A table full of numbers may be heaven to some and hell to others. This function allows you to visualise what's
going on in any particular gene. 

```{r}
# Proportion changes for all the transcripts of the "MIX6" gene.
plot_gene(mydtu, "MIX6", vals="proportions")
```

A variation of the above is to plot the mean fragment counts instead of the proportions:

```{r}
# Absolute expression changes for all the transcripts of the "MIX6" gene.
# The ERROR BARS represent 2 standard deviations from the mean count across replicates.
plot_gene(mydtu, "MIX6", vals="counts")
```

The two versions of the plot are best interpreted together, as no expression normalisation is carried out by `rats`.


### Plots of overall run

Our usual simulated dataset is too small to properly demonstrate what these plots typically would look like.
So each one is accompanied by an image of the same plot created with a real and much larger dataset.

Several of these plots are **likely to display warnings** about missing or non-finite values. These are due to the 
presence of `NA` in the tables, for reasons already discussed in the previous sections, and can be ignored.

Possibly the most common plot in differential expression is the volcano plot, which plots the effect size against 
the statistical significance. As it is difficult to define a single p-value and a single effect size at the gene level,
the volcano can only be plotted at the transcript level.

```{r}
# Proportion change VS significance.
plot_overview(mydtu, type="volcano")
```

And this is what it looks like on a larger dataset:
![Dprop VS sig](./fig/volcano.jpg)

The next command plots the largest change in proportion seen within each gene, against the number of genes showing 
such change. This is a way to inspect what effect sizes are present in the data. As an additional layer of information,
they are colour-coded by their DTU call.

```{r}
# Distribution of maximum proportion change.
plot_overview(mydtu, type="maxdprop")
```

And this is what it looks like on a larger dataset:
![Max Dprop](./fig/maxdprop.jpg)


### Plot customisation

You can save any of the plots as a `ggplot2` object and use [ggplot2](http://ggplot2.org) manipulations on it, such as changing the axis scales.
Other `ggplot2` customisations include the axis tick marks, axis values, labels, titles, colours... Consult the [ggplot2](http://ggplot2.org)
documentation for more help on these.

```{r}
library(ggplot2)

myplot <- plot_overview(mydtu, "volcano")
myplot  # display

# Change scale of y axis to linear. 
myplot2 <- myplot + scale_y_continuous(trans = "identity")
myplot2
```



## Advanced options


### Thresholds

Four thresholds can be set in `rats`.

```{r eval=FALSE}
# Calling DTU with custom thresholds.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", name_B = "patients", 
                  p_thresh = 0.01, count_thresh = 10, dprop_thresh = 0.25)
```

1. `p_thresh` - Significance level. P-values below this will be considered significant. 0.05 is a very permissive value.
2. `count_thresh` - At least one of the two conditions needs to exceed this number of fragments per sample for the transcript 
to be considered. Low counts have high uncertainty and low significance. Removing such entries from the analysis when both 
conditions are low-count improves the confidence in the predictions of the remaining transcripts, and reduces 
computation time. the reason this threshold requires only one condition to meet it is that enforcing it on both conditions 
would erroneously disqualify transcripts that may be silenced in one of the two conditions but highly expressed in the other.
3. `dprop_thresh` - This is a proxy for biological significance. A transcript's proportion must change by at least this much 
for it to be considered. The need for this is due to the fact that high counts will make even minute differences show up as 
statistically significant, however very small changes are likely to be biologically indifferent.
4. `conf_thresh` - Confidence threshold. Only applies when bootstraps are enabled. It sets the fraction of bootstrap iterations
that support the DTU call that are required to consider the call confident.

The default values for the first three thresholds are rather lenient. You may want to set them to stricter values, as they generally produce
many positive calls. The fourth threshold is set to a rather strict value. You can visualise its effect using
the plotting function discussed later in the section about bootstrapping.


### Comparing by different variables

So far, we've mostly compared conditions (`myslo$sample_to_covariates[["condition"]]`). Your data could contain other 
variables as well. As we saw in a previous example, our simulated data contains a variable called `batch`, with values
"ba" and "bb", according to the `myslo$sample_to_covariates` table.

```{r}
# Compare by a different variable. In this case "batch".
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "ba", name_B = "bb", 
                  varname= "batch", verbose = FALSE)
```


### Bootstrapping & Confidence in DTU calls

Bootstrapping of the DTU calls is enabled by default and their results were already discussed in the section
about output structure and the example results. Bootstrapping prolongs processing time considerably, 
but it provides a **measure of confidence in the p-values**, so we think it is important. 

Current transcript quantification algorithms such as [kallisto](https://pachterlab.github.io/kallisto/about), 
[salmon](https://combine-lab.github.io/salmon/) and [sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/) use 
probabilistic approaches to estimate transcript abundance. They all have the option to bootstrap their quantifications,
as required by Sleuth. We use these bootstrapped abundance estimations to control for the effect that
the variability in these quantifications has on the DTU calls.

Two parameters control bootstrapping of DTU calls on the abundance estimates:

1. `boots` - Although we recommend bootstrapping both gene-level and transcript-level DTU calls, dropping one would reduce
computation time, so the option is provided to allow flexibility for special use cases.
2. `bootnum` - Generally, greater is better but it takes longer. There is also an upper limit that depends on the size of 
your annotation. This is due to R's limit on the maximum size of matrices.

```{r eval=FALSE}
# Bootstrap both types of DTU calls (default), for 100 iterations (default).
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "both", bootnum = 100)

# Only bootstrap transcript calls.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "transc")

# Only bootstrap gene calls.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "genes")

# Skip bootstraps.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", boots = "none")
```

As measure of confidence in the DTU calls, we take the fraction of iterations that returned a positive DTU call for
the given gene/transcript. A positive call is considered confident if the fraction of positive calls exceeds the threshold (`>= conf_thresh`). 
A negative call is considered confident if the fraction of positive calls is below the complement of the threshold (`<= 1 - conf_thresh`).

The default confidence threshold is somewhat strict, but can be over-ridden.

```{r eval=FALSE}
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", conf_thresh = 0.9)
```

In order to visualise the effect of the confidence threshold, the number of positive DTU calls can be plotted against the threshold.

```{r eval=FALSE}
# Transcript-level confidence threshold VS. number of DTU positive calls.
plot_overview(mydtu, type="transc_conf")

# Gene-level confidence threshold VS. number of DTU positive calls.
plot_overview(mydtu, type="gene_conf")
```

This is what either of these plots looks like on a larger dataset:
![Transc Conf VS DTU](./fig/transc_conf.jpg)


### Test selection

`rats` runs gene-level calls (slower, lower detection threshold, less fine-grained) and transcript-level calls 
(faster, higher detection threshold, more fine-grained). They are complementary and we recommend using them
together, but the option to skip either is provided for special use cases. 
The fields of the skipped test will be filled with `NA`.

```{r eval=FALSE}
# Transcripts only.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", testmode="transc")
# Genes only.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", testmode="genes")
```


### Correction for multiple testing

Testing multiple null hypotheses increases the chance of one being falsely rejected. To keep the overall false rate at the 
desired level, the raw p-values must be adjusted. The default adjustment 
method is `BH` (Benjamini-Hochberg). A full list of options is listed in R's `p.adjust.methods`.

```{r eval=FALSE}
# Bonferroni correction.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "controls", 
                  name_B = "patients", correction = "bonferroni")
```


### Input structure flexibility

`rats` needs to pull information from different fields of the sleuth object and the annotation. For flexibility you can 
change the names of these fields.

```{r}
# Lets emulate some input with custom field names. 
sim <- sim_sleuth_data(varname="mouse", cnames=c("Splinter", "Mickey"), 
                       COUNTS_COL="the-counts", TARGET_COL="transcript", 
                       PARENT_COL="gene", BS_TARGET_COL = "trscr")
myslo <- sim$slo
myannot <- sim$annot

print( sim$slo$sample_to_covariates )
print( head(sim$slo$kal[[1]]$bootstrap[[1]]) )
print( head(sim$annot) )
```

With the field names changed, we need to tell `rats` where to find the data:

```{r}
# Call DTU on data with custom field names.
mydtu <- call_DTU(annot = myannot, slo = myslo, name_A = "Splinter", name_B = "Mickey", 
                  varname="mouse", TARGET_COL="transcript", PARENT_COL="gene", 
                  COUNTS_COL="the-counts", BS_TARGET_COL="trscr", verbose = FALSE)
```

The output structure will always use the same field names, regardless of what the input field names are.

```{r}
print( names(mydtu$Transcripts) )
```

* `varname` - The field name in `myslo$sample_to_covariates` where the desired condition names are listed.
* `TARGET_COL` - The name of the field holding the transcript identifiers in the annotation data frame.
* `PARENT_COL` - The name of the field holding the respective gene identifiers in the annotation data frame.
* `COUNTS_COL` - The name of the field holding the estimated counts in the sleuth object's bootstrap tables.
* `BS_TARGET_COL` - The name of the field holding the transcript identifiers in the sleuth object's bootstrap tables.


## Annotation discrepancies

The results sections mentioned the possibility that some transcripts/genes may be missing altogether from either the
annotation or the sleuth object. This is likely to be caused by use of different annotation versions during different
stages of the analysis. This is generally a **bad idea**, as there is no guarantee (at least for some annotations)
that the transcript identification codes will remain consistent between annotation versions. `rats` will not provide 
any warning about this, and will carry out the DTU calls in the most sensible way possible, assuming that the
intersection of transcript identifications between the sleuth data and annotation data frame are consistent. All
internal operations and the output will be based on the annotation data frame provided:

* Any transcripts/genes present in the counts data but missing from the annotation will be ignored completely and 
will not show up in the output.
* Any transcript/gene present in the annotation but missing from the count data will be padded with 
zero counts throughout and will be included in the output.
* If the samples appear to use different annotations from one another, `rats` will abort.


# Contact information

The rats R package was developed within [The Barton Group](http://www.compbio.dundee.ac.uk) at [The University of Dundee](http://www.dundee.ac.uk)
by Dr. Kimon Froussios, Dr. Kira MourÃ£o and Dr. Nick Schurch.

To **report problems** or **ask for assistance**, please raise a new issue [on the project's support forum](https://github.com/bartongroup/Rats/issues).
Providing a *reproducible working example* that demonstrates your issue is strongly encouraged to help us understand the problem. Also, be sure 
to **read the vignette(s)**, and browse/search the support forum before posting a new issue, in case your question is already answered there.

Enjoy!
